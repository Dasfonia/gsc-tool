/* Copyright 2020 xensik. All rights reserved.
//
// Use of this source code is governed by a GNU GPLv3 license
// that can be found in the LICENSE file.
*/

%require "3.7"
%skeleton "lalr1.cc"
%language "c++"
%output "./IW6/compiler_parser.cpp"
%defines "./IW6/compiler_parser.hpp"

%define api.value.type variant
%define api.token.constructor
%define api.token.raw
%define parse.assert
%define parse.trace
%define parse.error detailed
%define parse.lac full

%lex-param  { yyscan_t yyscanner } 
%parse-param { yyscan_t yyscanner } 
%parse-param { std::unique_ptr<node>& astout }

%code requires
{
	#include <utils.hpp>
	typedef void *yyscan_t; // fix yyscan_t error type no defined
	#define YY_DECL yy::parser::symbol_type yylex(yyscan_t yyscanner)

	using node_ptr = std::unique_ptr<node>;
	using script_ptr = std::unique_ptr<node_script>;
	using parameter_list_ptr = std::unique_ptr<node_parameter_list>;
	using stmt_block_ptr = std::unique_ptr<node_stmt_block>;
	using expr_arg_list_ptr = std::unique_ptr<node_expr_arg_list>;
}

/* compiler_parser.cpp code */
%code top
{
    #include "IW6.hpp"
	#include "compiler_parser.hpp"
	#include "compiler_lexer.hpp"

	yy::parser::symbol_type yylex(yyscan_t yyscanner);
}

%token INCLUDE USING_ANIMTREE ANIMTREE IF ELSE SWITCH
%token CASE DEFAULT BREAK FOR FOREACH WHILE CONTINUE
%token RETURN THREAD WAIT WAITTILL WAITTILLMATCH WAITTILLFRAMEEND
%token ENDON NOTIFY IN UNDEFINED TRUE FALSE SIZE GAME LEVEL

%token EMPTY_ARRAY LPAREN RPAREN LBRACE RBRACE LBRACKET RBRACKET
%token COMMA DOT DOUBLECOLON COLON SEMICOLON QMARK
%token MOD INC DEC LSHIFT RSHIFT CMP_OR CMP_AND CMP_EQUAL
%token CMP_NOT_EQ CMP_LESS_EQ CMP_GREATER_EQ CMP_LESS CMP_GREATER 
%token ASSIGN ASSIGN_ADD ASSIGN_SUB ASSIGN_MULT ASSIGN_DIV ASSIGN_MOD
%token ASSIGN_BW_OR ASSIGN_BW_AND ASSIGN_BW_XOR ASSIGN_LSHIFT ASSIGN_RSHIFT
%token BW_OR BW_AND BW_XOR ADD SUB MULT DIV NOT COMPLEMENT

%token <std::string> FILEPATH IDENTIFIER STRING STRING_LOC STRING_HASH FLOAT INTEGER

%type <std::unique_ptr<node_script>> script
%type <std::unique_ptr<node>> include using_animtree function
%type <std::unique_ptr<node_parameter_list>> parameter_list
%type <std::unique_ptr<node_stmt_block>> stmt_block

%type <std::unique_ptr<node>> stmt  stmt_call stmt_assign stmt_endon stmt_notify
%type <std::unique_ptr<node>> stmt_wait stmt_waittill stmt_waittillmatch stmt_waittillframeend
%type <std::unique_ptr<node>> stmt_if stmt_ifelse stmt_while stmt_for stmt_foreach 
%type <std::unique_ptr<node>> stmt_switch stmt_case stmt_default
%type <std::unique_ptr<node>> stmt_break stmt_continue stmt_return for_assign for_cond

%type <std::unique_ptr<node>> expr expr_assign expr_cmp expr_unary expr_binary expr_ternary
%type <std::unique_ptr<node>> expr_func_call_ptr expr_func_call expr_call expr_call_thread
%type <std::unique_ptr<node_expr_arg_list>> expr_arg_list

%type <std::unique_ptr<node>> object object_restricted expr_func_ref expr_subscribe expr_select
%type <std::unique_ptr<node>> num vector undefined empty_array game level false true size
%type <std::unique_ptr<node>> filepath identifier string string_loc string_hash num_integer num_float

%nonassoc IFX
%nonassoc ELSE

%start root

%%

root
	: script
		{ astout = std::move($1); }
	|
		{ astout = std::make_unique<node>(); }
	;

script
	: script include
		{ $$ = std::move($1); $$->childs.push_back(std::move($2)); }
	| script using_animtree
		{ $$ = std::move($1); $$->childs.push_back(std::move($2)); }
	| script function
		{ $$ = std::move($1); $$->childs.push_back(std::move($2)); }
	| include
		{ $$ = std::make_unique<node_script>(); $$->childs.push_back(std::move($1));}
	| using_animtree
		{ $$ = std::make_unique<node_script>(); $$->childs.push_back(std::move($1));}
	| function
		{ $$ = std::make_unique<node_script>(); $$->childs.push_back(std::move($1));}
	;

include
	: INCLUDE filepath SEMICOLON
		{ $$ = std::make_unique<node_include>(std::move($2)); }
	| INCLUDE identifier SEMICOLON
		{ $$ = std::make_unique<node_include>(std::move($2)); }
	;

using_animtree
	: USING_ANIMTREE LPAREN string RPAREN SEMICOLON
		{ $$ = std::make_unique<node_using_animtree>(std::move($3)); }
	;

function
	: identifier LPAREN parameter_list RPAREN LBRACE stmt_block RBRACE
		{ $$ = std::make_unique<node_function>(std::move($1), std::move($3), std::move($6)); }
	;

parameter_list
	: parameter_list COMMA identifier
		{ $$ = std::move($1); $$->params.push_back(std::move($3)); }
	| identifier
		{ $$ = std::make_unique<node_parameter_list>(); $$->params.push_back(std::move($1)); }
	|
		{ $$ = std::make_unique<node_parameter_list>(); }
	;

stmt_block
	: stmt_block stmt
		{ $$ = std::move($1); $$->stmts.push_back(std::move($2)); }
	| stmt
		{ $$ = std::make_unique<node_stmt_block>(); $$->stmts.push_back(std::move($1)); }
	|
		{ $$ = std::make_unique<node_stmt_block>(); }
	;

/* STATEMENTS */
stmt
	: stmt_call 								{ $$ = std::move($1); }
	| stmt_assign 								{ $$ = std::move($1); }
	| stmt_endon 								{ $$ = std::move($1); }
	| stmt_notify 								{ $$ = std::move($1); }
	| stmt_wait 								{ $$ = std::move($1); }
	| stmt_waittill 							{ $$ = std::move($1); }
	| stmt_waittillmatch 						{ $$ = std::move($1); }
	| stmt_waittillframeend 					{ $$ = std::move($1); }
	| stmt_if									{ $$ = std::move($1); }
	| stmt_ifelse								{ $$ = std::move($1); }
	| stmt_while								{ $$ = std::move($1); }
	| stmt_for									{ $$ = std::move($1); }
	| stmt_foreach								{ $$ = std::move($1); }
	| stmt_switch								{ $$ = std::move($1); }
	| stmt_case									{ $$ = std::move($1); }
	| stmt_default								{ $$ = std::move($1); }
	| stmt_break								{ $$ = std::move($1); }
	| stmt_continue								{ $$ = std::move($1); }
	| stmt_return								{ $$ = std::move($1); }
	;

stmt_call
	: expr_call SEMICOLON
		{ $$ = std::make_unique<node_stmt_call>(std::move($1)); }
	| expr_call_thread SEMICOLON
		{ $$ = std::make_unique<node_stmt_call>(std::move($1)); }
	;

stmt_assign
	: expr_assign SEMICOLON
		{ $$ = std::make_unique<node_stmt_assign>(std::move($1)); }
	;

stmt_endon
	: object_restricted ENDON LPAREN expr RPAREN SEMICOLON
		{ $$ = std::make_unique<node_stmt_endon>(std::move($1), std::move($4)); }
	;

stmt_notify
	: object_restricted NOTIFY LPAREN expr COMMA expr_arg_list RPAREN SEMICOLON
		{ $$ = std::make_unique<node_stmt_notify>(std::move($1), std::move($4), std::move($6)); }
	| object_restricted NOTIFY LPAREN expr RPAREN SEMICOLON
		{ $$ = std::make_unique<node_stmt_notify>(std::move($1), std::move($4), std::make_unique<node>()); }
	;

stmt_wait
	: WAIT LPAREN expr RPAREN SEMICOLON
		{ $$ = std::make_unique<node_stmt_wait>(std::move($3)); }
	| WAIT num SEMICOLON
		{ $$ = std::make_unique<node_stmt_wait>(std::move($2)); }
	;

stmt_waittill
	: object_restricted WAITTILL LPAREN expr COMMA expr_arg_list RPAREN SEMICOLON
		{ $$ = std::make_unique<node_stmt_waittill>(std::move($1), std::move($4), std::move($6)); }
	| object_restricted WAITTILL LPAREN expr RPAREN SEMICOLON
		{ $$ = std::make_unique<node_stmt_waittill>(std::move($1), std::move($4), std::make_unique<node>()); }
	;

stmt_waittillmatch
	: object_restricted WAITTILLMATCH LPAREN expr COMMA expr RPAREN SEMICOLON
		{ $$ = std::make_unique<node_stmt_waittillmatch>(std::move($1), std::move($4), std::move($6)); }
	;

stmt_waittillframeend
	: WAITTILLFRAMEEND SEMICOLON
		{ $$ = std::make_unique<node_stmt_waittillframeend>(); }
	;

stmt_if
	: IF LPAREN expr RPAREN LBRACE stmt_block RBRACE %prec IFX
		{ $$ = std::make_unique<node_stmt_if>(std::move($3), std::move($6)); }
	| IF LPAREN expr RPAREN stmt %prec IFX
		{ $$ = std::make_unique<node_stmt_if>(std::move($3), std::move($5)); }
	;

stmt_ifelse
	: IF LPAREN expr RPAREN LBRACE stmt_block RBRACE ELSE LBRACE stmt_block RBRACE
		{ $$ = std::make_unique<node_stmt_ifelse>(std::move($3), std::move($6), std::move($10)); }
	| IF LPAREN expr RPAREN stmt ELSE LBRACE stmt_block RBRACE
		{ $$ = std::make_unique<node_stmt_ifelse>(std::move($3), std::move($5), std::move($8)); }
	| IF LPAREN expr RPAREN LBRACE stmt_block RBRACE ELSE stmt
		{ $$ = std::make_unique<node_stmt_ifelse>(std::move($3), std::move($6), std::move($9)); }
	| IF LPAREN expr RPAREN stmt ELSE stmt
		{ $$ = std::make_unique<node_stmt_ifelse>(std::move($3), std::move($5), std::move($7)); }
	;

stmt_while
	: WHILE LPAREN expr RPAREN LBRACE stmt_block RBRACE
		{ $$ = std::make_unique<node_stmt_while>(std::move($3), std::move($6)); }
	| WHILE LPAREN expr RPAREN stmt
		{ $$ = std::make_unique<node_stmt_while>(std::move($3), std::move($5)); }
	;

stmt_for
	: FOR LPAREN for_assign SEMICOLON for_cond SEMICOLON for_assign RPAREN LBRACE stmt_block RBRACE
		{ $$ = std::make_unique<node_stmt_for>(std::move($3), std::move($5), std::move($7), std::move($10)); }
	|FOR LPAREN for_assign SEMICOLON for_cond SEMICOLON for_assign RPAREN stmt
		{ $$ = std::make_unique< node_stmt_for>(std::move($3), std::move($5), std::move($7), std::move($9)); }
	;

stmt_foreach
	: FOREACH LPAREN expr IN expr RPAREN RBRACE stmt_block RBRACE
		{ $$ = std::make_unique<node_stmt_foreach>(std::move($3), std::move($5), std::move($8)); }
	| FOREACH LPAREN expr IN expr RPAREN stmt
		{ $$ = std::make_unique<node_stmt_foreach>(std::move($3), std::move($5), std::move($7)); }
	;

stmt_switch
	: SWITCH LPAREN expr RPAREN LBRACE stmt_block RBRACE
		{ $$ = std::make_unique<node_stmt_switch>(std::move($3), std::move($6)); }
	;

stmt_case
	: CASE num_integer COLON
		{ $$ = std::make_unique<node_stmt_case>(std::move($2)); }
	| CASE string COLON
		{ $$ = std::make_unique<node_stmt_case>(std::move($2)); }
	;

stmt_default
	: DEFAULT COLON
		{ $$ = std::make_unique<node_stmt_default>(); }
	;

stmt_break
	: BREAK SEMICOLON 
		{ $$ = std::make_unique<node_stmt_break>(); }
	;
stmt_continue
	: CONTINUE SEMICOLON
		{ $$ = std::make_unique<node_stmt_continue>(); }
	;

stmt_return
	: RETURN expr SEMICOLON	
		{ $$ = std::make_unique<node_stmt_return>(std::move($2)); }
	| RETURN SEMICOLON
		{ $$ = std::make_unique<node_stmt_return>(std::make_unique<node>()); }
	;

for_assign
	: expr_assign 								{ $$ = std::move($1); }
	|											{ $$ = std::make_unique<node>(); }
	;

for_cond
	: expr_cmp 									{ $$ = std::move($1); }
	|											{ $$ = std::make_unique<node>(); }
	;

/* EXPRESSIONS */
expr
	: expr_cmp									{ $$ = std::move($1); }
	| expr_ternary								{ $$ = std::move($1); }
	| expr_binary								{ $$ = std::move($1); }
	| expr_unary								{ $$ = std::move($1); }
	;

expr_assign
	: object_restricted INC						{ $$ = std::make_unique<node_expr_inc>(std::move($1)); }
	| object_restricted DEC						{ $$ = std::make_unique<node_expr_dec>(std::move($1)); }
	| object_restricted ASSIGN expr				{ $$ = std::make_unique<node_expr_assign>(std::move($1), std::move($3)); }
	| object_restricted ASSIGN_BW_OR expr		{ $$ = std::make_unique<node_expr_assign_bw_or>(std::move($1), std::move($3)); }
	| object_restricted ASSIGN_BW_AND expr		{ $$ = std::make_unique<node_expr_assign_bw_and>(std::move($1), std::move($3)); }
	| object_restricted ASSIGN_BW_XOR expr		{ $$ = std::make_unique<node_expr_assign_bw_xor>(std::move($1), std::move($3)); }
	| object_restricted ASSIGN_LSHIFT expr		{ $$ = std::make_unique<node_expr_assign_shift_left>(std::move($1),std::move( $3)); }
	| object_restricted ASSIGN_RSHIFT expr 		{ $$ = std::make_unique<node_expr_assign_shift_right>(std::move($1), std::move($3)); }
	| object_restricted ASSIGN_ADD expr			{ $$ = std::make_unique<node_expr_assign_add>(std::move($1), std::move($3)); }
	| object_restricted ASSIGN_SUB expr			{ $$ = std::make_unique<node_expr_assign_sub>(std::move($1), std::move($3)); }
	| object_restricted ASSIGN_MULT expr		{ $$ = std::make_unique<node_expr_assign_mult>(std::move($1), std::move($3)); }
	| object_restricted ASSIGN_DIV expr			{ $$ = std::make_unique<node_expr_assign_div>(std::move($1), std::move($3)); }
	| object_restricted ASSIGN_MOD expr 		{ $$ = std::make_unique<node_expr_assign_mod>(std::move($1), std::move($3)); }
	;

expr_cmp
	: expr CMP_OR expr							{ $$ = std::make_unique<node_expr_cmp_or>(std::move($1), std::move($3)); }
	| expr CMP_AND expr							{ $$ = std::make_unique<node_expr_cmp_and>(std::move($1), std::move($3)); }
	| expr CMP_EQUAL expr						{ $$ = std::make_unique<node_expr_cmp_equal>(std::move($1), std::move($3)); }
	| expr CMP_NOT_EQ expr						{ $$ = std::make_unique<node_expr_cmp_not_equal>(std::move($1), std::move($3)); }
	| expr CMP_LESS_EQ expr						{ $$ = std::make_unique<node_expr_cmp_less_equal>(std::move($1), std::move($3)); }
	| expr CMP_GREATER_EQ expr					{ $$ = std::make_unique<node_expr_cmp_greater_equal>(std::move($1), std::move($3)); }
	| expr CMP_LESS expr						{ $$ = std::make_unique<node_expr_cmp_less>(std::move($1), std::move($3)); }
	| expr CMP_GREATER expr						{ $$ = std::make_unique<node_expr_cmp_greater>(std::move($1), std::move($3)); }
	;

expr_ternary
	: expr_cmp QMARK expr COLON expr   			{ $$ = std::make_unique<node_expr_ternary>(std::move($1), std::move($3), std::move($5)); }
	;

expr_binary
	: expr BW_OR expr							{ $$ = std::make_unique<node_expr_bw_or>(std::move($1), std::move($3)); }
	| expr BW_AND expr							{ $$ = std::make_unique<node_expr_bw_and>(std::move($1), std::move($3)); }
	| expr BW_XOR expr							{ $$ = std::make_unique<node_expr_bw_xor>(std::move($1), std::move($3)); }
	| expr LSHIFT expr							{ $$ = std::make_unique<node_expr_shift_left>(std::move($1), std::move($3)); }
	| expr RSHIFT expr 							{ $$ = std::make_unique<node_expr_shift_right>(std::move($1), std::move($3)); }
	| expr ADD expr								{ $$ = std::make_unique<node_expr_add>(std::move($1), std::move($3)); }
	| expr SUB expr								{ $$ = std::make_unique<node_expr_sub>(std::move($1), std::move($3)); }
	| expr MULT expr							{ $$ = std::make_unique<node_expr_mult>(std::move($1), std::move($3)); }
	| expr DIV expr								{ $$ = std::make_unique<node_expr_div>(std::move($1), std::move($3)); }
	| expr MOD expr 							{ $$ = std::make_unique<node_expr_mod>(std::move($1), std::move($3)); }
	;

expr_unary
	: COMPLEMENT expr							{ $$ = std::make_unique<node_expr_complement>(std::move($2)); }
	| NOT expr									{ $$ = std::make_unique<node_expr_not>(std::move($2)); }
	| expr_call									{ $$ = std::move($1); }
	| expr_call_thread							{ $$ = std::move($1); }
	| expr_select								{ $$ = std::move($1); }
	| expr_subscribe							{ $$ = std::move($1); }
	| expr_func_ref								{ $$ = std::move($1); }
	| empty_array								{ $$ = std::move($1); }
	| undefined									{ $$ = std::move($1); }
	| LPAREN expr COMMA expr COMMA expr RPAREN 	{ $$ = std::make_unique<node_expr_vector>(std::move($2), std::move($4), std::move($6)); }
	| vector									{ $$ = std::move($1); }
	| num 										{ $$ = std::move($1); }
	| string_hash								{ $$ = std::move($1); }
	| string_loc								{ $$ = std::move($1); }
	| string									{ $$ = std::move($1); }
	| identifier 								{ $$ = std::move($1); }
	| LPAREN expr RPAREN						{ $$ = std::move($2); }
	;

expr_call
	: expr_func_call							{ $$ = std::make_unique<node_expr_call>(std::make_unique<node>(), std::move($1)); }
	| expr_func_call_ptr						{ $$ = std::make_unique<node_expr_call>(std::make_unique<node>(), std::move($1)); }
	| object expr_func_call						{ $$ = std::make_unique<node_expr_call>(std::move($1), std::move($2)); }
	| object expr_func_call_ptr					{ $$ = std::make_unique<node_expr_call>(std::move($1), std::move($2)); }
	;

expr_call_thread
	: THREAD expr_func_call						{ $$ = std::make_unique<node_expr_call_thread>(std::make_unique<node>(), std::move($2)); }
	| THREAD expr_func_call_ptr  				{ $$ = std::make_unique<node_expr_call_thread>(std::make_unique<node>(), std::move($2)); }
	| object THREAD expr_func_call    			{ $$ = std::make_unique<node_expr_call_thread>(std::move($1), std::move($3)); }
	| object THREAD expr_func_call_ptr 			{ $$ = std::make_unique<node_expr_call_thread>(std::move($1), std::move($3)); }
	;

/* function("arg", 1) // file::function("arg", 1) */
expr_func_call
	: identifier LPAREN expr_arg_list RPAREN							{ $$ = std::make_unique<node_expr_func_call>(std::make_unique<node>(), std::move($1), std::move($3)); }
	| filepath DOUBLECOLON identifier LPAREN expr_arg_list RPAREN		{ $$ = std::make_unique<node_expr_func_call>(std::move($1), std::move($3), std::move($5)); }
	| identifier DOUBLECOLON identifier LPAREN expr_arg_list RPAREN		{ $$ = std::make_unique<node_expr_func_call>(std::move($1), std::move($3), std::move($5)); }
	;

/* [[function]]("0", 1) */
expr_func_call_ptr
	: LBRACKET LBRACKET expr RBRACKET RBRACKET LPAREN expr_arg_list RPAREN
		{ $$ = std::make_unique<node_expr_func_call_ptr>(std::move($3), std::move($7)); }
	;

expr_arg_list
	: expr_arg_list COMMA expr					{ $$ = std::move($1); $$->args.push_back(std::move($3)); }
	| expr										{ $$ = std::make_unique<node_expr_arg_list>(); $$->args.push_back(std::move($1)); }
	|											{ $$ = std::make_unique<node_expr_arg_list>(); }
	;

/* object.field */
expr_select
	: object DOT identifier						{ $$ = std::make_unique<node_expr_select>(std::move($1), std::move($3)); }
	| object DOT size							{ $$ = std::make_unique<node_expr_select>(std::move($1), std::move($3)); }
	;

/* array[ "key" ] */
expr_subscribe
	: object LBRACKET expr RBRACKET				{ $$ = std::make_unique<node_expr_subscribe>(std::move($1), std::move($3)); }
	;

/* ::callback, maps\load::callback */
expr_func_ref
 	: DOUBLECOLON identifier 					{ $$ = std::make_unique<node_expr_func_ref>(std::make_unique<node>(), std::move($2)); }
	| identifier DOUBLECOLON identifier 		{ $$ = std::make_unique<node_expr_func_ref>(std::move($1), std::move($3)); }
 	| filepath DOUBLECOLON identifier 			{ $$ = std::make_unique<node_expr_func_ref>(std::move($1), std::move($3)); }
	;

/* localvar.*, level.*, arrays[xx].*, var.id.*  func(xx).*  */
object
	: expr_call 								{ $$ = std::move($1); }
	| object_restricted							{ $$ = std::move($1); }
	;

/* can be refered (localvar = , level.* = , arrays[xx] = *) */
object_restricted
	: expr_subscribe 							{ $$ = std::move($1); }
	| expr_select 								{ $$ = std::move($1); }
	| identifier 								{ $$ = std::move($1); }
	| level										{ $$ = std::move($1); }
	| game										{ $$ = std::move($1); }
	;

size
	: SIZE
		{ $$ = std::make_unique<node_size>(); }
	;

false
	: FALSE
		{ $$ = std::make_unique<node_num_integer>("0"); }
	;

true
	: TRUE
		{ $$ = std::make_unique<node_num_integer>("1"); }
	;

level
	: LEVEL
		{ $$ = std::make_unique<node_level>(); }
	;

game
	: GAME
		{ $$ = std::make_unique<node_game>(); }
	;

empty_array 
	: EMPTY_ARRAY
		{ $$ = std::make_unique<node_empty_array>(); }
	;

undefined 
	: UNDEFINED
		{ $$ = std::make_unique<node_undefined>(); }
	;

vector 
	: LPAREN num COMMA num COMMA num RPAREN
		{ $$ = std::make_unique<node_vector>(std::move($2), std::move($4), std::move($6)); }
	;

num
	: num_float 								{ $$ = std::move($1); }
	| num_integer 								{ $$ = std::move($1); }
	| false										{ $$ = std::move($1); }
	| true										{ $$ = std::move($1); }
	;

num_float 
	: FLOAT 									{ $$ = std::make_unique<node_num_float>($1); }
	;

num_integer 
	: INTEGER 									{ $$ = std::make_unique<node_num_integer>($1); }
	;

string_hash 
	: STRING_HASH 								{ $$ = std::make_unique<node_string_hash>($1); }
	;

string_loc
	: STRING_LOC 								{ $$ = std::make_unique<node_string_loc>($1); }
	;

string
	: STRING 									{ $$ = std::make_unique<node_string>($1); }
	;

identifier 
	: IDENTIFIER 								{ $$ = std::make_unique<node_identifier>($1); }
	;

filepath 
	: FILEPATH 									{ $$ = std::make_unique<node_filepath>($1); }
	;

%%


void yy::parser::error(const std::string& msg)
{
    std::cout << "An error occured: " << msg << std::endl;
}
